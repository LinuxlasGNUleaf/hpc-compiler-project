
@ <stdio.hdr>
@ <string.hdr>

@ "lexer.hdr"
@ "string.hdr"

// -- internal: only available within this translation unit

global ch: int;
global currentPos: Pos = {1, 0};
global lengthVal: size_t = 0;
global val: string;

fn nextCh(updateVal: bool)
{
    if (updateVal) {
        val[lengthVal++] = ch;
        val[lengthVal] = 0;
        assert(lengthVal < sizeof(val) / sizeof(val[0]));
    } else {
        lengthVal = 0;
    }
    ch = getchar();
    if (ch == '\n') {
        ++currentPos.row;
        currentPos.col = 0;
    } else {
        ++currentPos.col;
    }
}

fn isDigit(ch: int): bool
{
    return ch >= '0' && ch <= '9';
}

fn isLetter(ch: int): bool
{
    return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z';
}

fn getTokenInternal(): TokenKind
{
    lengthVal = 0;
    while (ch == 0 || ch == ' ' || ch == '\n' || ch == '\t') {
        nextCh(false);
    }
    token.pos = currentPos;
    if (isDigit(ch)) {
        while (isDigit(ch)) {
            nextCh(true);
        }
        return token.kind = DECIMAL_LITERAL;
    } else if (isLetter(ch)) {
        while (isLetter(ch) || isDigit(ch)) {
            nextCh(true);
        }
        return token.kind = IDENTIFIER;
    } else if (ch == '+') {
        nextCh(true);
        return token.kind = PLUS;
    } else if (ch == '-') {
        nextCh(true);
        return token.kind = MINUS;
    } else if (ch == '*') {
        nextCh(true);
        return token.kind = ASTERISK;
    } else if (ch == '/') {
        nextCh(true);
        return token.kind = SLASH;
    } else if (ch == '(') {
        nextCh(true);
        return token.kind = LPAREN;
    } else if (ch == ')') {
        nextCh(true);
        return token.kind = RPAREN;
    } else if (ch == ';') {
        nextCh(true);
        return token.kind = SEMICOLON;
    } else if (ch == '=') {
        nextCh(true);
        return token.kind = EQUAL;
    } else if (ch == '&') {
        nextCh(true);
        return token.kind = AMPERSAND;
    } else if (ch == '{') {
        nextCh(true);
        return token.kind = LBRACE;
    } else if (ch == '}') {
        nextCh(true);
        return token.kind = RBRACE;
    } else if (ch == EOF) {
        return token.kind = EOI;
    } else {
        nextCh(true);
        return token.kind = BAD_TOKEN;
    }
}

// -- exported: available for other translation units

global token: Token;

fn getToken(): TokenKind
{
    getTokenInternal();
    token.val = UStrCreate(val);
    if (token.kind == IDENTIFIER)
    {
        if (!strcmp(token.val, "fn")) {
            return token.kind = FN;
        } else if (!strcmp(token.val, "while")) {
            return token.kind = WHILE;
        } else if (!strcmp(token.val, "if")) {
            return token.kind = IF;
        } else if (!strcmp(token.val, "else")) {
            return token.kind = ELSE;
        }
    }
    return token.kind;

}

fn tokenKindStr(token: TokenKind): -> char
{
    switch (token) {
        case BAD_TOKEN: return "BAD_TOKEN";
        case EOI: return "EOI";
        case DECIMAL_LITERAL: return "DECIMAL_LITERAL";
        case IDENTIFIER: return "IDENTIFIER";
        case PLUS: return "PLUS";
        case MINUS: return "MINUS";
        case ASTERISK: return "ASTERISK";
        case SLASH: return "SLASH";
        case LPAREN: return "LPAREN";
        case RPAREN: return "RPAREN";
        case SEMICOLON: return "SEMICOLON";
        case EQUAL: return "EQUAL";
        case AMPERSAND: return "AMPERSAND";
        case LBRACE: return "LBRACE";
        case RBRACE: return "RBRACE";
        case FN: return "FN";
        case WHILE: return "WHILE";
        case IF: return "IF";
        case ELSE: return "ELSE";
        default: return "??";
    }
}
