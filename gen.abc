@ <stdio.hdr>
@ <string.hdr>

@ "genvar.hdr"
@ "gen.hdr"

global usedReg: array[16] of bool;

fn getReg(): GenReg
{
    for (local r: GenReg = 4; r < sizeof(usedReg)/sizeof(usedReg[0]); r++) {
        if (!usedReg[r]) {
            usedReg[r] = true;
            return r;
        }
    }
    assert (0 && "getReg: out of registers!\n");
    return 0;
}

fn genReleaseReg(reg: GenReg)
{
    assert(usedReg[reg]);
    usedReg[reg] = false;
}

fn genConstant(val: -> UStr): GenReg
{
    local reg: GenReg = getReg();
    printf("\tload\t%s,\t\t\t\t%%%d\n", val, reg);
    return reg;
}

fn genInstr(instr: GenInstr, left: GenReg, right: GenReg): GenReg
{
    local reg: GenReg = getReg();
    switch (instr) {
        case GEN_ADD:
            printf("\tadd\t\t%%%d,\t\t\t\t%%%d,\t\t\t\t%%%d\n", right, left, reg);
            break;
        case GEN_SUB:
            printf("\tsub\t\t%%%d,\t\t\t\t%%%d,\t\t\t\t%%%d\n", right, left, reg);
            break;
        case GEN_MUL:
            printf("\tmul\t\t%%%d,\t\t\t\t%%%d,\t\t\t\t%%%d\n", right, left, reg);
            break;
        case GEN_DIV:
            printf("\tdiv\t\t%%%d,\t\t\t\t%%%d,\t\t\t\t%%%d\n", right, left, reg);
            break;
        default:
            assert(0 && "Interal error: genInstr");
            return 0;
    }
    return reg;
}

fn genHalt(exitCode: GenReg)
{
    printf("\thalt\t%%%d\n", exitCode);
}

fn genLoadAddress(varName: -> UStr): GenReg
{
    genAddGlobalVar(varName);
    local reg: GenReg = getReg();
    if (strlen(varName) > 4) {
        printf("\tload\t%s,\t\t%%%d\n", varName, reg);
    } else if (strlen(varName) > 1) {
        printf("\tload\t%s,\t\t\t%%%d\n", varName, reg);
    } else {
        printf("\tload\t%s,\t\t\t\t%%%d\n", varName, reg);
    }
    return reg;
}

fn genFetch(addr: GenReg): GenReg
{
    local reg: GenReg = getReg();
    printf("\tmovq\t(%%%d),\t\t\t%%%d\n", addr, reg);
    return reg;
}

fn genStore(val: GenReg, addr: GenReg)
{
    printf("\tmovq\t%%%d,\t\t\t\t(%%%d)\n", val, addr);
}

fn genInit()
{
    printf("\t.equ\tSP,\t\t\t\t1\n");
    printf("\t.equ\tFP,\t\t\t\t2\n");
    printf("\t.equ\tretval,\t\t\t16\n");
    printf("\t.text\n");
    printf("\tload\t0,\t\t\t\t%%SP\n");
    genPrepareFunctionCall(0);
    local reg: GenReg = genExecuteFunctionCall("main", 0);
    genHalt(reg);
    genReleaseReg(reg);

    genBeginFunctionDefinition("getchar");
    printf("\tgetc\t%%4\n");
    genEndFunctionDefinition();

    genBeginFunctionDefinition("putchar");
    printf("\tload\tPUTCHAR,\t\t%%4\n");
    printf("\tmovq\t(%%4),\t\t\t%%4\n");
    printf("\tputc\t%%4\n");
    genEndFunctionDefinition();

    genAddGlobalVar(UStrCreate("PUTCHAR"));

}

fn genBeginFunctionDefinition(name: ->UStr)
{
    printf("%s:\n", name);
    printf("\tmovq\t%%3,\t\t\t\t(%%SP)\n");
    printf("\tmovq\t%%FP,\t\t\t8(%%SP)\n");
    printf("\tmovq\t%%SP,\t\t\t%%FP\n");
    printf("\t// begin function body\n");
}

fn genEndFunctionDefinition()
{
    printf("\t// store return value\n");
    printf("\tmovq\t%%4,\t\t\t\tretval(%%FP)\n");
    printf("\t//end function body\n");
    printf("\tmovq\t%%FP,\t\t\t%%SP\n");
    printf("\tmovq\t8(%%SP),\t\t\t%%FP\n");
    printf("\tmovq\t(%%SP),\t\t\t%%3\n");
    printf("\tret\t\t%%3\n");
}

fn genPrepareFunctionCall(numArgs: int)
{
    printf("\tsub\t\t8*(3 + %d),\t\t%%SP,\t\t\t%%SP\n", numArgs);
}

fn genExecuteFunctionCall(name: -> UStr, numArgs: int): GenReg
{
    local reg: GenReg = getReg();
    if (strlen(name) > 4) {
        printf("\tcall\t%s,\t\t%%3\n", name);
    } else {
        printf("\tcall\t%s,\t\t\t%%3\n", name);
    }
    printf("\tmovq\tretval(%%SP),\t%%%d\n", reg);
    printf("\tadd\t\t8*(3 + %d),\t\t%%SP,\t\t\t%%SP\n", numArgs);
    return reg;
}
