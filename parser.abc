
@ <stdio.hdr>

@ "parser.hdr"
@ "lexer.hdr"
@ "gen.hdr"

fn parseFunction(): bool
{
    if (token.kind != FN) {
        return false;
    }
    getToken();
    if (token.kind != IDENTIFIER) {
        printf("%u.%u: function name expected\n",
               token.pos.row, token.pos.col);
        return false;
    }
    genBeginFunctionDefinition(token.val);
    getToken();
    if (!parseCompoundStatement()) {
        printf("%u.%u: compound expression expected\n",
               token.pos.row, token.pos.col);
        return false;
    }
    genEndFunctionDefinition();
    return true;
}

fn parseExprStatement(): bool
{
    local expr: -> Expr = parseExpr();
    if (!expr) {
        return false;
    }
    if (token.kind != SEMICOLON) {
        printf("%u.%u: ';' expected\n", token.pos.row, token.pos.col);
        return false;
    }
    getToken();
    genReleaseReg(loadExpr(expr));
    return true;
}

fn parseCompoundStatement(): bool
{
    if (token.kind != LBRACE) {
        return false;
    }
    getToken();
    while (parseCompoundStatement() || parseWhileStatement() || parseExprStatement()) {
    }
    if (token.kind != RBRACE) {
        printf("%u.%u: '}' expected\n", token.pos.row, token.pos.col);
        return false;
    }
    getToken();
    return true;
}

fn parseWhileStatement(): bool
{
    static count: int = 0;
    if (token.kind != WHILE) {
        return false;
    }
    getToken();
    ++count;
    printf("while%d:\n", count);
    if (token.kind != LPAREN) {
        printf("%u.%u: '(' expected\n",
               token.pos.row, token.pos.col);
        return false;
    }
    getToken();
    local expr: -> Expr = parseExpr();
    if (!expr) {
        printf("%u.%u: expression expected\n",
               token.pos.row, token.pos.col);
        return false;
    }
    if (token.kind != RPAREN) {
        printf("%u.%u: ')' expected\n",
               token.pos.row, token.pos.col);
        return false;
    }
    getToken();
    local reg: GenReg = loadExpr(expr);
    printf("\tsub\t\t%%0,\t\t\t\t%%%d,\t\t\t\t%%0\n", reg);
    printf("\tjz\t\tdone%d\n", count);
    genReleaseReg(reg);

    if (!parseCompoundStatement()) {
        printf("%u.%u: compund expression expected\n",
               token.pos.row, token.pos.col);
   }
   printf("\tjmp\t\twhile%d\n", count);
   printf("done%d:\n", count);
   return true;
}

fn parseExpr(): -> Expr
{
    local left: ->Expr = parseAdditive();
    while (token.kind == EQUAL) {
        getToken();
        local right: ->Expr = parseExpr();
        if (!right) {
            printf("%u.%u expected additive\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        left = createBinaryExpr(EXPR_ASSIGN, left, right);
    }
    return left;
}

fn parseAdditive(): ->Expr
{
    local left: ->Expr = parseTerm();
    if (!left) {
        return nullptr;
    }
    while (token.kind == PLUS || token.kind == MINUS) {
        local exprKind: ExprKind = exprKindFromToken(token);
        getToken();
        local right: ->Expr = parseTerm();
        if (!right) {
            printf("%u.%u expected term\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        left = createBinaryExpr(exprKind, left, right);
    }
    return left;
}

fn parseTerm(): ->Expr
{
    local left: ->Expr = parseUnary();
    if (!left) {
        return nullptr;
    }
    while (token.kind == ASTERISK || token.kind == SLASH) {
        local exprKind: ExprKind = exprKindFromToken(token);
        getToken();
        local right: ->Expr = parseUnary();
        if (!right) {
            printf("%u.%u expected term\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        left = createBinaryExpr(exprKind, left, right);
    }
    return left;
}

fn parseUnary(): -> Expr
{
    if (token.kind == ASTERISK) {
        getToken();
        local child: ->Expr = parseUnary();
        if (!child) {
            printf("%u.%u expected unary\n",
                   token.pos.row, token.pos.col);
            assert(0);
            return nullptr;
        }
        return createDerefExpr(child);
    } else if (token.kind == AMPERSAND) {
        getToken();
        local child: ->Expr = parseUnary();
        if (!addressableExpr(child)) {
            printf("%u.%u: expression has no address\n",
                  token.pos.row, token.pos.col);
            assert(0);
            return nullptr;
        }
        return createAddrExpr(child);
    } else {
        return parseFactor();
    }
}

fn parseFactor(): -> Expr
{
    if (token.kind == DECIMAL_LITERAL) {
        local expr: ->Expr = createIntegerExpr(token.val);
        getToken();
        return expr;
    } else if (token.kind == IDENTIFIER) {
        local val: -> UStr = token.val;
        getToken();
        if (token.kind == LPAREN) {
            getToken();
            if (token.kind != RPAREN) {
                printf("%u.%u: ')' expected\n", token.pos.row, token.pos.col);
                return nullptr;
            }
            getToken();
            return createCallExpr(val);
        } else {
            return createIdentifierExpr(val);
        }
    } else if (token.kind == LPAREN) {
        getToken();
        local expr: ->Expr = parseExpr();
        if (!expr) {
            printf("%u.%u expected expression\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        if (token.kind != RPAREN) {
            printf("%u.%u expected ')'\n",
                   token.pos.row, token.pos.col);
            assert(0);
        }
        getToken();
        return expr;
    } else {
        return nullptr;
    }
}

fn exprKindFromToken(token: Token): ExprKind
{
    switch (token.kind) {
        case ASTERISK:  return EXPR_MUL;
        case SLASH:     return EXPR_DIV;
        case PLUS:      return EXPR_ADD;
        case MINUS:     return EXPR_SUB;
        case EQUAL:     return EXPR_ASSIGN;
        default:
            assert(0 && "internal error: exprKindFromToken");
            return 0;
    }
}

fn addressableExpr(expr: ->Expr): bool
{
    if (expr->kind == EXPR_IDENTIFIER)
    {
        return true;
    } else if (expr->kind == EXPR_DEREF || expr->kind == EXPR_ASSIGN){
        return true;
    } else {
        return false;
    }
}
